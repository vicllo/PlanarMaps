/* Automatically generated by /home/victor/sage/src/sage_setup/autogen/interpreters/generator.py.  Do not edit! */
#include <Python.h>

#include <gsl/gsl_math.h>
double interp_rdf(double* args,
        double* constants,
        PyObject** py_constants,
        double* stack,
        int* code) {
  while (1) {
    switch (*code++) {
    case 0: /* load_arg */
      {
        int ai0 = *code++;
        double i0 = args[ai0];
        double o0;
        o0 = i0;
        *stack++ = o0;
      }
      break;
    case 1: /* load_const */
      {
        int ai0 = *code++;
        double i0 = constants[ai0];
        double o0;
        o0 = i0;
        *stack++ = o0;
      }
      break;
    case 2: /* return */
      {
        double i0 = *--stack;
        return i0;
      }
      break;
    case 3: /* py_call */
      {
        int ai0 = *code++;
        PyObject* i0 = py_constants[ai0];
        int n_i1 = *code++;
        stack -= n_i1;
        double* i1 = stack;
        double o0;

        PyObject *py_args = PyTuple_New(n_i1);
        if (py_args == NULL) goto error;
        int i;
        for (i = 0; i < n_i1; i++) {
          PyObject *arg = PyFloat_FromDouble(i1[i]);
          if (arg == NULL) {
            Py_DECREF(py_args);
            goto error;
          }
          PyTuple_SET_ITEM(py_args, i, arg);
        }
        PyObject *result = PyObject_CallObject(i0, py_args);
        Py_DECREF(py_args);
        if (result == NULL) goto error;
        /* If result is not a float, then this will turn it into a float first. */
        o0 = PyFloat_AsDouble(result);
        Py_DECREF(result);
        if (o0 == -1 && PyErr_Occurred()) {
          goto error;
        }
        *stack++ = o0;
      }
      break;
    case 4: /* pow */
      {
        double i1 = *--stack;
        double i0 = *--stack;
        double o0;

        /* See python's pow in floatobject.c */
        if (i0 == 0) o0 = 1.0;
        else {
          if (i0 < 0 && i1 != floor(i1)) {
              PyErr_SetString(PyExc_ValueError, "negative number to a fractional power not real");
              goto error;
          }
          o0 = pow(i0, i1);
        }
        *stack++ = o0;
      }
      break;
    case 5: /* add */
      {
        double i1 = *--stack;
        double i0 = *--stack;
        double o0;
        o0 = i0 + i1;
        *stack++ = o0;
      }
      break;
    case 6: /* sub */
      {
        double i1 = *--stack;
        double i0 = *--stack;
        double o0;
        o0 = i0 - i1;
        *stack++ = o0;
      }
      break;
    case 7: /* mul */
      {
        double i1 = *--stack;
        double i0 = *--stack;
        double o0;
        o0 = i0 * i1;
        *stack++ = o0;
      }
      break;
    case 8: /* div */
      {
        double i1 = *--stack;
        double i0 = *--stack;
        double o0;
        o0 = i0 / i1;
        *stack++ = o0;
      }
      break;
    case 9: /* ipow */
      {
        int i1 = *code++;
        double i0 = *--stack;
        double o0;
        o0 = gsl_pow_int(i0, i1);
        *stack++ = o0;
      }
      break;
    case 10: /* neg */
      {
        double i0 = *--stack;
        double o0;
        o0 = -i0;
        *stack++ = o0;
      }
      break;
    case 11: /* invert */
      {
        double i0 = *--stack;
        double o0;
        o0 = 1/i0;
        *stack++ = o0;
      }
      break;
    case 12: /* abs */
      {
        double i0 = *--stack;
        double o0;
        o0 = fabs(i0);
        *stack++ = o0;
      }
      break;
    case 13: /* sqrt */
      {
        double i0 = *--stack;
        double o0;
        o0 = sqrt(i0);
        *stack++ = o0;
      }
      break;
    case 14: /* ceil */
      {
        double i0 = *--stack;
        double o0;
        o0 = ceil(i0);
        *stack++ = o0;
      }
      break;
    case 15: /* floor */
      {
        double i0 = *--stack;
        double o0;
        o0 = floor(i0);
        *stack++ = o0;
      }
      break;
    case 16: /* sin */
      {
        double i0 = *--stack;
        double o0;
        o0 = sin(i0);
        *stack++ = o0;
      }
      break;
    case 17: /* cos */
      {
        double i0 = *--stack;
        double o0;
        o0 = cos(i0);
        *stack++ = o0;
      }
      break;
    case 18: /* tan */
      {
        double i0 = *--stack;
        double o0;
        o0 = tan(i0);
        *stack++ = o0;
      }
      break;
    case 19: /* asin */
      {
        double i0 = *--stack;
        double o0;
        o0 = asin(i0);
        *stack++ = o0;
      }
      break;
    case 20: /* acos */
      {
        double i0 = *--stack;
        double o0;
        o0 = acos(i0);
        *stack++ = o0;
      }
      break;
    case 21: /* atan */
      {
        double i0 = *--stack;
        double o0;
        o0 = atan(i0);
        *stack++ = o0;
      }
      break;
    case 22: /* sinh */
      {
        double i0 = *--stack;
        double o0;
        o0 = sinh(i0);
        *stack++ = o0;
      }
      break;
    case 23: /* cosh */
      {
        double i0 = *--stack;
        double o0;
        o0 = cosh(i0);
        *stack++ = o0;
      }
      break;
    case 24: /* tanh */
      {
        double i0 = *--stack;
        double o0;
        o0 = tanh(i0);
        *stack++ = o0;
      }
      break;
    case 25: /* asinh */
      {
        double i0 = *--stack;
        double o0;
        o0 = asinh(i0);
        *stack++ = o0;
      }
      break;
    case 26: /* acosh */
      {
        double i0 = *--stack;
        double o0;
        o0 = acosh(i0);
        *stack++ = o0;
      }
      break;
    case 27: /* atanh */
      {
        double i0 = *--stack;
        double o0;
        o0 = atanh(i0);
        *stack++ = o0;
      }
      break;
    case 28: /* exp */
      {
        double i0 = *--stack;
        double o0;
        o0 = exp(i0);
        *stack++ = o0;
      }
      break;
    case 29: /* log */
      {
        double i0 = *--stack;
        double o0;
        o0 = log(i0);
        *stack++ = o0;
      }
      break;
    }
  }
error:
  return -1094648009105371;
}

