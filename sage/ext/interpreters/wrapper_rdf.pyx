# Automatically generated by /home/victor/sage/src/sage_setup/autogen/interpreters/generator.py.  Do not edit!
cimport sage.libs.gsl.math  # Add dependency on GSL

from cpython.ref cimport PyObject
cdef extern from "Python.h":
    void Py_DECREF(PyObject *o)
    void Py_INCREF(PyObject *o)
    void Py_CLEAR(PyObject *o)

    object PyList_New(Py_ssize_t len)
    ctypedef struct PyListObject:
        PyObject **ob_item

    ctypedef struct PyTupleObject:
        PyObject **ob_item

from cysignals.memory cimport check_allocarray, sig_free

from sage.ext.fast_callable cimport Wrapper

cdef extern from "interp_rdf.c":
    double interp_rdf(double* args,
        double* constants,
        PyObject** py_constants,
        double* stack,
        int* code) except? -1094648009105371

cdef class Wrapper_rdf(Wrapper):
    # attributes are declared in corresponding .pxd file

    def __init__(self, args):
        Wrapper.__init__(self, args, metadata)
        cdef int i
        cdef int count
        count = args['args']
        self._n_args = count
        self._args = <double*>check_allocarray(self._n_args, sizeof(double))
        val = args['constants']
        self._n_constants = len(val)
        self._constants = <double*>check_allocarray(self._n_constants, sizeof(double))
        for i in range(len(val)):
            self._constants[i] = val[i]
        val = args['py_constants']
        self._n_py_constants = len(val)
        self._list_py_constants = PyList_New(self._n_py_constants)
        self._py_constants = (<PyListObject *>self._list_py_constants).ob_item
        for i in range(len(val)):
            self._py_constants[i] = <PyObject *>val[i]; Py_INCREF(self._py_constants[i])
        count = args['stack']
        self._n_stack = count
        self._stack = <double*>check_allocarray(self._n_stack, sizeof(double))
        val = args['code']
        self._n_code = len(val)
        self._code = <int*>check_allocarray(self._n_code, sizeof(int))
        for i in range(len(val)):
            self._code[i] = val[i]
        self._domain = args['domain']

    def __dealloc__(self):
        cdef int i
        if self._args:
            sig_free(self._args)
        if self._constants:
            sig_free(self._constants)
        if self._stack:
            sig_free(self._stack)
        if self._code:
            sig_free(self._code)

    def __call__(self, *args):
        if self._n_args != len(args): raise ValueError
        cdef double* c_args = self._args
        cdef int i
        for i from 0 <= i < len(args):
            self._args[i] = args[i]
        return self._domain(interp_rdf(c_args
            , self._constants
            , self._py_constants
            , self._stack
            , self._code
            ))

    cdef bint call_c(self,
                     double* args,
                     double* result) except 0:
        result[0] = interp_rdf(args
            , self._constants
            , self._py_constants
            , self._stack
            , self._code
            )

        return 1

from sage.ext.fast_callable import CompilerInstrSpec, InterpreterMetadata
metadata = InterpreterMetadata(by_opname={
  'load_arg':
  (CompilerInstrSpec(0, 1, ['args']), 0),
  'load_const':
  (CompilerInstrSpec(0, 1, ['constants']), 1),
  'return':
  (CompilerInstrSpec(1, 0, []), 2),
  'py_call':
  (CompilerInstrSpec(0, 1, ['py_constants', 'n_inputs']), 3),
  'pow':
  (CompilerInstrSpec(2, 1, []), 4),
  'add':
  (CompilerInstrSpec(2, 1, []), 5),
  'sub':
  (CompilerInstrSpec(2, 1, []), 6),
  'mul':
  (CompilerInstrSpec(2, 1, []), 7),
  'div':
  (CompilerInstrSpec(2, 1, []), 8),
  'ipow':
  (CompilerInstrSpec(1, 1, ['code']), 9),
  'neg':
  (CompilerInstrSpec(1, 1, []), 10),
  'invert':
  (CompilerInstrSpec(1, 1, []), 11),
  'abs':
  (CompilerInstrSpec(1, 1, []), 12),
  'sqrt':
  (CompilerInstrSpec(1, 1, []), 13),
  'ceil':
  (CompilerInstrSpec(1, 1, []), 14),
  'floor':
  (CompilerInstrSpec(1, 1, []), 15),
  'sin':
  (CompilerInstrSpec(1, 1, []), 16),
  'cos':
  (CompilerInstrSpec(1, 1, []), 17),
  'tan':
  (CompilerInstrSpec(1, 1, []), 18),
  'asin':
  (CompilerInstrSpec(1, 1, []), 19),
  'acos':
  (CompilerInstrSpec(1, 1, []), 20),
  'atan':
  (CompilerInstrSpec(1, 1, []), 21),
  'sinh':
  (CompilerInstrSpec(1, 1, []), 22),
  'cosh':
  (CompilerInstrSpec(1, 1, []), 23),
  'tanh':
  (CompilerInstrSpec(1, 1, []), 24),
  'asinh':
  (CompilerInstrSpec(1, 1, []), 25),
  'acosh':
  (CompilerInstrSpec(1, 1, []), 26),
  'atanh':
  (CompilerInstrSpec(1, 1, []), 27),
  'exp':
  (CompilerInstrSpec(1, 1, []), 28),
  'log':
  (CompilerInstrSpec(1, 1, []), 29),
 },
 by_opcode=[
  ('load_arg',
   CompilerInstrSpec(0, 1, ['args'])),
  ('load_const',
   CompilerInstrSpec(0, 1, ['constants'])),
  ('return',
   CompilerInstrSpec(1, 0, [])),
  ('py_call',
   CompilerInstrSpec(0, 1, ['py_constants', 'n_inputs'])),
  ('pow',
   CompilerInstrSpec(2, 1, [])),
  ('add',
   CompilerInstrSpec(2, 1, [])),
  ('sub',
   CompilerInstrSpec(2, 1, [])),
  ('mul',
   CompilerInstrSpec(2, 1, [])),
  ('div',
   CompilerInstrSpec(2, 1, [])),
  ('ipow',
   CompilerInstrSpec(1, 1, ['code'])),
  ('neg',
   CompilerInstrSpec(1, 1, [])),
  ('invert',
   CompilerInstrSpec(1, 1, [])),
  ('abs',
   CompilerInstrSpec(1, 1, [])),
  ('sqrt',
   CompilerInstrSpec(1, 1, [])),
  ('ceil',
   CompilerInstrSpec(1, 1, [])),
  ('floor',
   CompilerInstrSpec(1, 1, [])),
  ('sin',
   CompilerInstrSpec(1, 1, [])),
  ('cos',
   CompilerInstrSpec(1, 1, [])),
  ('tan',
   CompilerInstrSpec(1, 1, [])),
  ('asin',
   CompilerInstrSpec(1, 1, [])),
  ('acos',
   CompilerInstrSpec(1, 1, [])),
  ('atan',
   CompilerInstrSpec(1, 1, [])),
  ('sinh',
   CompilerInstrSpec(1, 1, [])),
  ('cosh',
   CompilerInstrSpec(1, 1, [])),
  ('tanh',
   CompilerInstrSpec(1, 1, [])),
  ('asinh',
   CompilerInstrSpec(1, 1, [])),
  ('acosh',
   CompilerInstrSpec(1, 1, [])),
  ('atanh',
   CompilerInstrSpec(1, 1, [])),
  ('exp',
   CompilerInstrSpec(1, 1, [])),
  ('log',
   CompilerInstrSpec(1, 1, [])),
 ],
 ipow_range=(-2147483648, 2147483647))
