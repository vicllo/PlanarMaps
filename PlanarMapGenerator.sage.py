

# This file was *autogenerated* from the file PlanarMapGenerator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_30 = Integer(30)
load("PlanarMap.sage")
import random

def cube():
	"""Returns the standard cube map."""
	return PlanarMap(adj = [(_sage_const_5 ,_sage_const_4 ,_sage_const_2 ),(_sage_const_1 ,_sage_const_3 ,_sage_const_6 ),(_sage_const_4 ,_sage_const_7 ,_sage_const_2 ),(_sage_const_8 ,_sage_const_3 ,_sage_const_1 ),(_sage_const_8 ,_sage_const_1 ,_sage_const_6 ),(_sage_const_5 ,_sage_const_2 ,_sage_const_7 ),(_sage_const_3 ,_sage_const_8 ,_sage_const_6 ),(_sage_const_7 ,_sage_const_4 ,_sage_const_5 )])

def complete_map(n):
	"""
	Returns an arbitrary map corresponding to the complete graph with n nodes.
	The genus is guaranteed to be zero if the graph is planar (i.e. n <= 4).
	"""

	adj = list(tuple((j+i)%n + _sage_const_1  for j in range(_sage_const_1 ,n)) for i in range(n))
	m = PlanarMap(adj = adj)

	if n <= _sage_const_4 :
		m = m.force_planar()
	
	return m

def getRandomDyckPath(n):
    """
    Returns a random dyck path of size n (uniform random generation)

    Args: 
		int n : size of path
    """
    N = _sage_const_2  * n + _sage_const_1 
    dyck = [_sage_const_1 ] * n + [-_sage_const_1 ] * (n + _sage_const_1 ) 
    random.shuffle(dyck)

    level = _sage_const_0 
    minlevel = _sage_const_0 
    posmin = _sage_const_0 

    for i in range(N):
        level += dyck[i]
        if level < minlevel:
            posmin = i + _sage_const_1 
            minlevel = level

    Dyckfinal = [dyck[(posmin + i) % N] for i in range(N - _sage_const_1 )]
    return Dyckfinal

def test_getRandomDyckPath():
    for k in range(_sage_const_3 ,_sage_const_30 ,_sage_const_3 ):
		dyck_path = getRandomDyckPath(k)
		negative = False 
		level = _sage_const_0 
		for step in dyck_path:
			level += step
			if level < _sage_const_0 : 
				negative = True
		assert (negative is False) and (level == _sage_const_0 )  



