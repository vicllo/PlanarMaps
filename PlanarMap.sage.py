

# This file was *autogenerated* from the file PlanarMap.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_8 = Integer(8); _sage_const_4 = Integer(4); _sage_const_6 = Integer(6)
from sage.all_cmdline import *   # import sage library


class PlanarMap:
	def __init__(self, sigma:Permutation, alpha:Permutation):
		"""
		A class to represent a planar map.

		Attributes
		----------
		sigma : Permutation
			Fixed-point free involution whose cycles are given by the edges
		alpha : Permutation
			Permutation that maps a half-edge to the half-edge incident to it in clockwise direction, around the vertex it belongs to.
		
		Methods:
		-------
		"""
		self.sigma = sigma
		self.alpha = alpha
		self.phi = self.alpha.right_action_product(self.sigma)
		self.size = self.sigma.size()
		self.m = self.size / _sage_const_2  

		if self.sigma.size() != self.alpha.size():
			raise ValueError("The two permutations does not have the same size")

		if self.alpha.right_action_product(self.alpha) != Permutations(self.size).identity():
			raise ValueError("The permutation alpha is not an involution")
		
		if self.alpha.number_of_fixed_points() != _sage_const_0 :
			raise ValueError("The permutation alpha should not have fixed points")

		seen = [False] * (self.size + _sage_const_1  )
		seen[_sage_const_0 ] = True  # On s'évite les décalages d'indices de la sorte

		def dfs(i):
			seen[i] = True
			if not seen[self.alpha(i)]:
				dfs(self.alpha(i))
			if not seen[self.sigma(i)]:
				dfs(self.sigma(i))
		dfs(_sage_const_1 )

		if False in seen:
			raise ValueError("The graph isn't connected")


	def buildGraph(self):
		"""
		A method that build the multigraph corresponding to the planar map
		-------
		O(m)
		where m is the number of edges
		"""
		vertices = self.sigma.to_cycles()
		corres = [_sage_const_0 ] * int(_sage_const_2  * self.m + _sage_const_1 )			# associe à une demi-arête le sommet correspondant
		for i in range(_sage_const_1 , len(vertices)+_sage_const_1 ):
			for k in vertices[i-_sage_const_1 ]:
				corres[k] = i
		
		edges = []

		for i in range(_sage_const_1 , _sage_const_2 *self.m+_sage_const_1 ):			# pour chaque demi-arête, on ajoute une arête entre corres[i] et corres[alpha(i)]
			if i < self.alpha(i):					# on évite d'ajouter les arêtes en double
				edges.append((corres[i], corres[self.alpha(i)]))

		return Graph(edges, loops = True, multiedges = True)


	def __repr__(self):
		return "Sigma : " + str(self.sigma) + ", Alpha : " + str(self.alpha)


	def numberOfFaces(self):
		"""
		A method that return the number of faces of the planar map
		-------
		O(m)
		where m is the number of edges
		"""
		return len(self.phi.to_cycles())


	def numberOfNodes(self):
		"""
		A method that return the number of vertices of the planar map
		-------
		O(m)
		where m is the number of edges
		"""
		return len(self.sigma.to_cycles())
	

	def numberOfEdges(self):
		"""
		A method that return the number of edges of the planar map
		-------
		O(1)
		"""
		return self.m


	def dual(self):
		"""
		A method that return the dual of the planar map
		-------
		O(m)
		where m is the number of edges
		"""
		return PlanarMap(self.phi.inverse(),self.alpha)
	

	def diameter(self):
		"""
		A method that return the diameter of the planar map
		-------
		O(m*n)
		where m is the number of edges and n is the number of nodes
		"""
		graph = self.buildGraph()
		return Graph.diameter(graph)


	def derivedMap(self):

		""" 
		A method that return the derived Map of the planar map
		-------
		O(m)
		where m is the number of edges
		"""
		K = _sage_const_8 *self.m+_sage_const_1 
		
		derivedAlphaList = list(range(_sage_const_1 ,K))
		derivedSigmaList = list(range(_sage_const_1 ,K))

		invPhi = self.phi.inverse()

		m = int(self.m)


		for i in list(range(_sage_const_1 ,K)):
			if i<=_sage_const_2 *m:
				derivedAlphaList[i-_sage_const_1 ] = i+_sage_const_2 *m
				derivedSigmaList[i-_sage_const_1 ] = self.sigma(i)
			elif i>_sage_const_2 *m and i<=_sage_const_4 *m:
				derivedAlphaList[i-_sage_const_1 ] = i-_sage_const_2 *m
				derivedSigmaList[i-_sage_const_1 ] = i+_sage_const_4 *m
			elif i>_sage_const_4 *m and i<=_sage_const_6 *m:
				derivedAlphaList[i-_sage_const_1 ] = i+_sage_const_2 *m
				derivedSigmaList[i-_sage_const_1 ] = invPhi(i-_sage_const_4 *m)+_sage_const_4 *m
			else:
				derivedAlphaList[i-_sage_const_1 ] = i-_sage_const_2 *m
				derivedSigmaList[i-_sage_const_1 ] = self.alpha(i-_sage_const_6 *m)+_sage_const_2 *m

		derivedSigma = Permutation(derivedSigmaList)
		derivedAlpha = Permutation(derivedAlphaList)
		return PlanarMap(derivedSigma,derivedAlpha)


	def incidenceMap(self):
		""" 
		A method that return the incidence Map of the planar map
		-------
		O(m)
		where m is the number of edges
		"""

		face = list(range(_sage_const_2 *self.m+_sage_const_1 ))

		phiCycles = self.phi.to_cycles()
		invPhi = self.phi.inverse()

		for k in range(len(phiCycles)):
			for demiEdge in phiCycles[k]:
				face[demiEdge] = k
		

		t = _sage_const_1 
		sigmaInciList = []
		corres = [-_sage_const_1 ]
		invCorres  = list(range(_sage_const_2 *self.m+_sage_const_1 ))

		for k in range(len(phiCycles)):
			l = _sage_const_0 
			t0 = t
			while l<len(phiCycles[k]):
				demiEdge = phiCycles[k][l]
				
				if face[demiEdge] == face[self.alpha(demiEdge)]:
					cnt = _sage_const_1 
					l+=_sage_const_1 

					while l<len(phiCycles[k]) and face[phiCycles[k][l]] == face[self.alpha(phiCycles[k][l])]:
						cnt+=_sage_const_1 
						l+=_sage_const_1 

					for j in range(cnt//_sage_const_2 ):
						t+=_sage_const_1 
						corres.append(-_sage_const_1 )
						sigmaInciList.append(-_sage_const_1 )

				else:
					sigmaInciList.append(-_sage_const_1 )
					corres.append(-_sage_const_1 )
					corres[t] = demiEdge
					invCorres[demiEdge] = t
					t+=_sage_const_1 
					l+=_sage_const_1 	

			if len(phiCycles) == _sage_const_1 :
				sigmaInciList.append(-_sage_const_1 )
				corres.append(-_sage_const_1 )
				t+=_sage_const_1 

			for x in range(t0+_sage_const_1 ,t):
				sigmaInciList[x-_sage_const_1 ] = x-_sage_const_1 
					
			sigmaInciList[t0-_sage_const_1 	] = t-_sage_const_1 

		N = len(sigmaInciList)


		for j in range(N):
			sigmaInciList.append(-_sage_const_1 )

		alphaInciList = list(range(_sage_const_2 *N))

		for j in range(_sage_const_1 ,N+_sage_const_1 ):
			alphaInciList[j-_sage_const_1 ] = j+N 
			alphaInciList[j+N-_sage_const_1 ] = j
			
			if corres[j] == -_sage_const_1 :
				sigmaInciList[j+N-_sage_const_1 ] = j+N
			else:
				demiEdge = corres[j]
				sigmaInciList[j+N-_sage_const_1 ] = invCorres[self.sigma(demiEdge)]+N

		alphaInci = Permutation(alphaInciList)
		sigmaInci = Permutation(sigmaInciList)

		return PlanarMap(sigmaInci,alphaInci)

